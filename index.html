<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>EQ Chart.Js</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <script src=js/Chart.min.js></script>
    <script src=js/jquery-3.2.1.min.js></script>
    <script>
        /* x range */
        const MinHz = 20;
        const MaxHz = 250;
        /* point number and delta */
        const COUNT = 230;
        const DELTA = (MaxHz - MinHz) / COUNT;
        /* BW index convert Q */
        const BWtoQ = {
             0: 1.0,
             1: 1.1,
             2: 1.2,
             3: 1.3,
             4: 1.5,
             5: 1.8,
             6: 2.0,
             7: 2.3,
             8: 2.6,
             9: 3.0,
            10: 4.0,
            11: 5.0,
        };
        /* custom function */
        const MR2dB_COEF = 20.0 / Math.LN10;
        const MR2dB = magResponse => MR2dB_COEF * Math.log(magResponse);
        const setValueAtTime = (obj, value, time) => obj["setValueAtTime"](value, time);
        const requestAnimationFrame = f => window.setTimeout(f, 300);
        const createBiquadFilter = (atx, type) => {
            const filter = atx.createBiquadFilter();
            filter.type = type;
            return filter;
        }
    </script>
    <style>
        input {
            outline: 0px;
            -webkit-appearance: none;
            background-color: gainsboro;
            display: block;
            width: 100%;
        }
        input::after {
            content: attr(prefix)attr(result);
            display: block;
            width: 65px;
            line-height:160%;
            color:black;
            background-color: grey;
        }
    </style>
</head>
<body>
    <canvas id="eq-chart" width=360 height=300 style="margin:auto;border:solid 1px"></canvas>
    <div>
        <label style=color:blue>Low Pass</label>
        <input type="range" class=F min=20  max=250 value=200 prefix="Hz = ">
        <input type="range" class=Q min=0   max=11  value=0   prefix="Q = ">
        <input type="range" class=G min=-10 max=10  value=0   prefix="Gain = ">
        <hr>
        <label style=color:green>Peaking</label>
        <input type="range" class=F min=20  max=250 value=50 prefix="Hz = ">
        <input type="range" class=Q min=0   max=11  value=0  prefix="Q = ">
        <input type="range" class=G min=-10 max=10  value=0  prefix="Gain = ">
    </div>
</body>
<script>
    const atx = new (window.AudioContext || window.webkitAudioContext)();
    var filter1/* = createBiquadFilter(atx,"lowpass")*/;
    var filter2/* = createBiquadFilter(atx,"peaking")*/;
    const filterArray = [
        filter1 = createBiquadFilter(atx,"lowpass"),
        filter2 = createBiquadFilter(atx,"peaking"),
    ];
    /* connect */
    filterArray.reduce((pre, cur) => pre.connect(cur)).connect(atx.destination);
</script>
<script>
    const DataSet = (f => (f.prototype = {
        fill: false,
        borderWidth: 0.2,
        lineTension: 0, // Set to 0 to draw straightlines, default = 0.4
        cubicInterpolationMode: 'monotone',
        pointRadius: 0,
        pointHitRadius: 0,
    }) && f)(function (extend) { return $.extend(this, extend) });
    const eqChart = new Chart(document.getElementById('eq-chart'), {
        type: 'line',
        data: {
            datasets: [
                new DataSet({
                    label: "ParaGraphic EQ",
                    backgroundColor: 'red',
                    borderColor: 'red',
                    borderWidth: 1,
                }),
                new DataSet({
                    label: "LowPass",
                    backgroundColor: 'blue',
                    borderColor: 'blue',
                }),
                new DataSet({
                    label: "Peaking",
                    backgroundColor: 'green',
                    borderColor: 'green',
                }),
                new DataSet({
                    label: "原點水平線",
                    backgroundColor: 'black',
                    borderColor: 'black',
                    data: [{ x: MinHz, y: 0 }, { x: MaxHz, y: 0 }]
                }),
            ]
        },
        options: {
            responsive: false,
            layout: {
                // padding: {
                //     left: -5
                // }
            },
            legend: {
                // display: false
                labels: {
                    filter: label => label.datasetIndex == 0
                }
            },
            scales: {
                xAxes: [{
                    // display:false,
                    type: 'logarithmic',
                    ticks: {
                        min: MinHz,
                        max: MaxHz,
                        maxRotation: 0,
                        // maxTicksLimit: 2,
                        callback: v => v + "Hz"
                    },
                }],
                yAxes: [{
                    ticks: {
                        // mirror: true,
                        // padding: -5,
                        suggestedMin: -10,
                        suggestedMax:  10,
                        maxTicksLimit:  5,
                        callback: v => Math.round(v*100)/100 + "dB"
                    },
                    gridLines: {
                        display: false
                    }
                }]
            },
            /*
                http://www.chartjs.org/docs/latest/charts/line.html#disable-animations
                Disable Animations
            */
            animation: {
                duration: 0, // general animation time
            },
            hover: {
                animationDuration: 0, // duration of animations when hovering an item
            },
            responsiveAnimationDuration: 0, // animation duration after a resize
        }
    });
    const frequencyHz = new Float32Array(COUNT).map((_, i) => MinHz + i * DELTA);
    const pointsArray = [
        // prepare pointsArray[0]
        frequencyHz.reduce((points, f) => (points.push({ x: f, y: 0 }) && points), [])
    ];
    const Chart_EQ = () => {
        /* stream Array */
        filterArray
        .map((filter, index) => {
            var magResponse = new Float32Array(COUNT);
            filter.getFrequencyResponse(frequencyHz, magResponse, new Float32Array(COUNT));
            magResponse.reduce((points, mr, i) => (points.push({ x: frequencyHz[i], y: MR2dB(mr)}) && points), pointsArray[index + 1] = []);
            return magResponse;
        })
        .reduce((points, magResponse, index) => points.map((p, j) => {
            if (index == 0) p.y = 0; // reset
            p.y += MR2dB(magResponse[j]);
            return p
        }), pointsArray[0]);
        /* update datasets */
        pointsArray.forEach((points, i) => eqChart.data.datasets[i].data = points);
        /* plot */
        eqChart.update();
    }
</script>
<script>
    $(() => {
        /* custom extent jquery function */
        $.fn.extend({valueQ: function () {
            return this.map((_, input) => $(input).hasClass("Q") ? BWtoQ[input.value] : input.value).toArray();
        }});
        /* init + listen input */
        const inputRangeSetting = ($input, param) => {
            // 設定 result 屬性 -> 給 ::after 參照
            $input.attr('result', $input.valueQ());
            // 更新 filter 參數
            setValueAtTime(param, $input.valueQ(), atx.currentTime);
        };
        const inputRangeHandler = ($input, param) => {
            // 設定更新
            inputRangeSetting($input, param);
            // 監聽 input
            $input.on("input", () => {
                // 設定更新
                inputRangeSetting($input, param);
                // 繪圖
                requestAnimationFrame(Chart_EQ);
            });
        };
        $(".F").each((index, input) => inputRangeHandler($(input), filterArray[index].frequency));
        $(".Q").each((index, input) => inputRangeHandler($(input), filterArray[index].Q));
        $(".G").each((index, input) => inputRangeHandler($(input), filterArray[index].gain));
        /* first time plot */
        requestAnimationFrame(Chart_EQ);
    });
</script>
</html>